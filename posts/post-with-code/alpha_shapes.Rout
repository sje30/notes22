
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin21.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## alpha_shapes.R
> ## last updated: 2011-04-02
> 
> matfile <- "P4_14Jun11_spont_ctl__hotMaps.mat"
> alpha <- 6.4
> 
> ## Type "colors()" at the R prompt to get a list of colournames that you
> ## can use here.
> active.col <- "green"
> inside.col <- "black"
> outside.col <- "lightgrey"
> 
> ## Set the following to TRUE/FALSE to state
> ## if you need PDF or Postscript output.
> ## 
> need.pdf <- TRUE
> need.postscript <- FALSE
> 
> ## Which waves do you want to see plotted?
> waves.to.plot <- "all"                  #if you want to see them all.
> ##waves.to.plot <- c(71)             # if you just want to see a few.
> 
> ######################################################################
> ## Nothing else below to edit.
> ######################################################################
> 
> require(R.matlab)
Loading required package: R.matlab
R.matlab v3.7.0 (2022-08-25 21:52:34 UTC) successfully loaded. See ?R.matlab for help.

Attaching package: ‘R.matlab’

The following objects are masked from ‘package:base’:

    getOption, isOpen

> require(alphahull)
Loading required package: alphahull
> require(lattice)
Loading required package: lattice
> ##trellis.device(color = FALSE)
> 
> get.coords <- function(X, noise=0.0001) {
+   ## X is a 2d matrix.
+   ## Return the 2d location of the coordinates, with tiny bit of noise
+   ## to stop geometry problems.
+   pts <- which(X>0, arr.ind=TRUE)
+   pts + matrix(rnorm(nrow(pts)*2)*noise, ncol=2)
+ }
> 
> get.id <- function(X) {
+   ## X is a 2d matrix.
+   ## Return the ID of each active electrode.
+   which(X>0, arr.ind=FALSE)
+ }
> 
> 
> inahullM <- function(hull, X) {
+   ## Each row of X is a point P to pass to inahill(hull, P)
+   apply(X, 1, function(p) {inahull3(hull, p)})
+ }
> 
> plot.one.wave <- function(n) {
+   hull <- hulls[[n]]
+   inside <- inahullM(hull, E)
+   title <- sprintf("w %d: d = %d/%d = %.2f; a = %.1f\n", n,
+                    n.active[n], n.insiders[n], density[n],
+                    areas[n])
+   ## origin in top-left corner
+   plot(hull, asp=1, main=title,
+        xaxt="n", yaxt="n",
+        xlab="", ylab="",
+        xlim=c(0,64), ylim=c(64,0), wpoints=FALSE)
+   active <- R[[n]]
+   stopifnot(length(active) == n.active[n])
+   pt.col <- ifelse(inside, inside.col, outside.col)
+   pt.col[active] <- active.col
+   points(E, pch=20, col=pt.col, cex=0.4)
+   if (FALSE) {
+     plot(shapes[[n]], add=T,
+          col='blue',wpoints=F,lwd=0.4)  #add the alphashape
+   }
+   rect(0,0, 64,64, lty=2, lwd=0.5)
+ 
+   ## Add a scalebar
+   segments(0, 66, 10, 66)
+ }
> 
> id.to.row <- function(ids, E.id) {
+   ## IDS is set of electrode ids; look them up and
+   ## return the corresponding locations.
+   rows <- match(ids, E.id)
+   if (any(is.na(rows)))
+     browser()
+   rows
+ }
> 
> row.to.coords <- function(rows, E) {
+   E[rows,]
+ }
> 
> inahull3<-function (ahull.obj, p, tol=10e-5) 
+ {
+   ## This function emailed to me from Beatriz, author of alphahull.
+ 
+ compl <- ahull.obj$complement
+ wh<-which(compl[,3]==ahull.obj$alpha)
+ compl<-compl[-wh,]
+ compl<-rbind(ahull.obj$arcs[,1:3],compl[,1:3])
+ 
+ 
+     halfpl <- which(compl[, "r"] < 0)
+     n.halfpl <- length(halfpl)
+     ball <- which(compl[, "r"] > 0)
+     n.ball <- length(ball)
+     in.compl <- FALSE
+     if (n.halfpl >= 1) {
+         h <- 1
+         while ((h <= n.halfpl) & in.compl == FALSE) {
+             sig = compl[halfpl[h], 3]
+             a = compl[halfpl[h], 1]
+             b = compl[halfpl[h], 2]
+             if (sig <= -3) {
+                 if (p[1] > (a+tol)) {
+                   if (sig == -3) {
+                     in.compl <- TRUE
+                   }
+                 }
+                 else if (p[1] < (a-tol)) {
+                   if (sig == -4) {
+                     in.compl <- TRUE
+                   }
+                 }
+             }
+             else {
+                 if (p[2] > a + b * p[1]+tol) {
+                   if (sig == -1) {
+                     in.compl <- TRUE
+                   }
+                 }
+                 else if (p[2] < a + b * p[1]-tol) {
+                   if (sig == -2) {
+                     in.compl <- TRUE
+                   }
+                 }
+             }
+             h <- h + 1
+         }
+     }
+     if (in.compl == FALSE) {
+         k <- 1
+         while ((k <= n.ball) & in.compl == FALSE) {
+             r = compl[ball[k], 3]
+             c1 = compl[ball[k], 1]
+             c2 = compl[ball[k], 2]
+             d <- sqrt((p[1] - c1)^2 + (p[2] - c2)^2)
+             if (d < r-tol) {
+                 in.compl <- TRUE
+             }
+             k <- k + 1
+         }
+     }
+     return(in.ahull = !in.compl)
+ }
> 
> ######################################################################
> ## End of functions
> ######################################################################
> 
> 
> ## This is the set of all active electrodes.
> 
> csvfile <- gsub(".mat$", "_alpha.csv", matfile)
> pdffile <- gsub(".mat$", "_alpha.pdf", matfile)
> psfile <- gsub(".mat$", "_alpha.ps", matfile)
> pdfolapfile <- gsub(".mat$", "_alpha_olap.pdf", matfile)
> 
> matdata <- readMat(matfile)
> 
> E <- get.coords(matdata$overallHotMap, noise=0.001)
> E.id <- get.id(matdata$overallHotMap)
> plot(E, pch=20, main="electrode positions in recording")
> 
> 
> hotmaps <- matdata$hotMaps
> names(hotmaps) <- NULL  ## important - else levelplots won't display! with NAs.
> ##length(hotmaps) <- 10
> n.waves <- length(hotmaps)
> cat(sprintf("About to analyse %d waves\n", n.waves))
About to analyse 75 waves
> ##I <- lapply(hotmaps, get.id)
> get.id2 <- function(hotmap) {
+   m = hotmap[[1]]
+   a = m[[1]]
+   dim(a)
+   get.id(m)
+ }
> get.id2(hotmaps[[2]])
  [1]   85  145  199  209  212  214  259  270  272  327  329  330  338  341  344
 [16]  391  392  395  408  409  410  457  474  531  538  543  547  588  595  600
 [31]  602  667  671  672  710  727  728  732  733  785  797  798  799  802  804
 [46]  856  858  859  861  862  868  915  919  928  931  932  933  948  980  989
 [61]  990  991  992  997 1030 1034 1041 1045 1046 1047 1052 1098 1099 1110 1113
 [76] 1114 1116 1120 1123 1158 1159 1161 1164 1169 1170 1173 1174 1175 1182 1186
 [91] 1228 1229 1232 1233 1236 1237 1243 1245 1246 1249 1293 1295 1300 1302 1303
[106] 1304 1306 1309 1310 1313 1324 1330 1359 1360 1368 1370 1371 1377 1421 1424
[121] 1431 1434 1443 1445 1450 1457 1504 1505 1507 1515 1517 1520 1540 1552 1562
[136] 1563 1569 1581 1582 1583 1584 1585 1588 1603 1604 1624 1627 1632 1633 1642
[151] 1645 1646 1671 1680 1681 1686 1690 1692 1699 1704 1705 1710 1711 1714 1715
[166] 1716 1719 1720 1721 1722 1723 1736 1738 1739 1741 1747 1748 1753 1754 1755
[181] 1756 1777 1780 1782 1783 1797 1801 1804 1806 1807 1811 1812 1814 1815 1842
[196] 1843 1844 1845 1847 1848 1849 1850 1866 1868 1874 1883 1884 1903 1904 1907
[211] 1911 1912 1930 1933 1934 1942 1944 1945 1947 1966 1968 1969 1970 1972 1976
[226] 1977 1978 1979 1999 2005 2009 2030 2031 2034 2039 2040 2065 2070 2095 2102
[241] 2103 2131 2163 2164 2169 2171 2184 2194 2195 2222 2227 2228 2231 2232 2233
[256] 2234 2255 2256 2260 2296 2297 2312 2313 2318 2349 2361 2389 2406 2409 2415
[271] 2426 2441 2470 2471 2473 2492 2515 2518 2529 2530 2533 2536 2545 2546 2554
[286] 2555 2568 2586 2591 2610 2611 2618 2651 2654 2655 2658 2659 2665 2672 2674
[301] 2709 2715 2719 2720 2721 2722 2731 2738 2766 2783 2786 2790 2792 2801 2834
[316] 2835 2847 2850 2856 2857 2858 2861 2862 2866 2900 2909 2912 2915 2916 2923
[331] 2929 2973 2987 2997 3038 3041 3056 3101 3102 3105 3113 3116 3117 3126 3137
[346] 3170 3173 3174 3295 3313 3358 3446 3489 3490 3491 3566 3608 3811 3948 4020
> 
> I <- lapply(hotmaps, get.id2)
> 
> ## Derive the position of each wave from the E map, which has
> ## been jittered.
> R <- lapply(I, id.to.row, E.id)
> C <- lapply(R, row.to.coords, E)
> 
> 
> ## C <- lapply(hotmaps, get.coords)
> 
> n.active <- sapply(I, length)           #number of active electrodes
> 
> hulls  <- lapply(C, ahull, alpha=alpha)
> shapes <- lapply(C, ashape, alpha=alpha)
> areas  <- sapply(hulls, areaahull)
> insiders <-sapply(hulls, function(hull) { which(inahullM(hull, E))})
> n.insiders <- sapply(insiders, length)
> density <- round(n.active/n.insiders,3)
> 
> cat("About to calculate overlaps\n")
About to calculate overlaps
> shared.electrodes <- shared.insiders <- matrix(NA, nrow=n.waves, ncol=n.waves)
> for (i in 1:(n.waves-1)) {
+   for (j in (i+1):n.waves) {
+     shared.electrodes[i,j] <- length(intersect(I[[i]], I[[j]]))
+     shared.insiders[i,j] <- length(intersect(insiders[[i]], insiders[[j]]))
+   }
+ }
> 
> 
> min.active <- outer(n.active, n.active, pmin)
> min.insiders <- outer(n.insiders, n.insiders, pmin)
> shared.electrodes.frac <-  shared.electrodes/min.active
> shared.insiders.frac <-    shared.insiders/min.insiders
> 
> ## adapted from ?image, with volcano.
> ##f <- function(m) {t(m)[ncol(m):1,]}
> f <- function(m) {m}
> 
> p1 <- levelplot(f(shared.electrodes), main="shared.active (n)")
> p2 <- levelplot(f(shared.insiders), main="shared.insiders (n)")
> p3 <- levelplot(f(shared.electrodes.frac), main='shared.active (fraction)')
> p4 <- levelplot(f(shared.insiders.frac), main='shared.insiders (fraction)')
> 
> pdf(file=pdfolapfile, width=8, height=8)
> print(p1, position=c(0.0, 0.0, 0.5, 0.5), more=TRUE)
> print(p2, position=c(0.5, 0.0, 1.0, 0.5), more=TRUE)
> print(p3, position=c(0.0, 0.5, 0.5, 1.0), more=TRUE)
> print(p4, position=c(0.5, 0.5, 1.0, 1.0), more=FALSE)
> dev.off()
quartz 
     2 
> 
> 
> #######################################################################
> ## Which waves do we want to plot?
> if (is.character(waves.to.plot) && (waves.to.plot == "all")) {
+   waves.to.plot = 1:n.waves
+ }
> 
> ## qpdf can compress:
> ## qpdf --stream-data=compress P4__hotMaps_alpha.pdf a.pdf
> 
> if (need.pdf) {
+   pdf(file=pdffile,width=8, height=11)
+   par(mfrow=c(3,2), xaxt="n", yaxt="n")
+   for (i in waves.to.plot) {
+     plot.one.wave(i)
+   }
+   dev.off()
+ }
quartz 
     2 
> 
> if (need.postscript) {
+   postscript(file=psfile,width=8, height=11, onefile=FALSE, horizontal=FALSE)
+   par(mfrow=c(3,2), xaxt="n", yaxt="n")
+   for (i in waves.to.plot) {
+     plot.one.wave(i)
+   }
+   dev.off()
+ }
> 
> 
> 
> 
> 
> df <- data.frame(wave=1:n.waves,
+                  area=round(areas,3),
+                  n.active=n.active,
+                  n.inside=n.insiders,
+                  density=density)
> write.csv(df, file=csvfile, row.names=FALSE)
> 
> ## area and n.inside are well-correlated.
> plot(df$area, df$n.inside, xlab='alphahull area', ylab='#electrodes inside')
> 
> 
> 
> proc.time()
   user  system elapsed 
 60.766   1.323  62.261 
